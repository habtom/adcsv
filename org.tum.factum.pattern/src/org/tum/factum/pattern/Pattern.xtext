grammar org.tum.factum.pattern.Pattern with org.eclipse.xtext.common.Terminals
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate pattern "http://www.tum.org/factum/pattern/Pattern"
Pattern returns Pattern:
	
	{Pattern} 
	'Pattern' name=ID 'ShortName' psname=ID
	'{'
		('DTSpec' '{' dtSpec+=DataTypeSpec( "," dtSpec+=DataTypeSpec)* '}' )?
		('CTypes' '{' componentTypes+=ComponentType	( "," componentTypes+=ComponentType)* '}' )?
 
	    ('ArchSpec' '{'
	    	(ctaCmpVar+=ComponentVariable ("," ctaCmpVar+=ComponentVariable)*) 	//Declaration of Component Variables
	    	(ctaDtVars=DTVariables)?											//Declaration of DT Variables

			(ctaFormulaIds+=CtaFormulasID)*
	    '}'
	    )?
	    ('ArchGuarantee' '{'
			(agCmpVar+=ComponentVariable ("," agCmpVar+=ComponentVariable)*)
			(agDtVars=DTVariables)?
			
			(agFormulaIds+=AgFormulasID)*
	    '}')?
	    
		('SubPattern' '{' SubPattern+=Pattern ( "," SubPattern+=Pattern)* '}' )?
	'}'
;
ComponentType returns ComponentType:
	{ComponentType} 
	'CType'	name=ID ('ShortName' ctsname=ID)? 
	'{'
	    ('InputPorts' '{' inputPorts+=InputPort ( "," inputPorts+=InputPort)* '}' )?
	    ('OutputPorts' '{' outputPorts+=OutputPort ( "," outputPorts+=OutputPort)* '}' )?
	    ('Parameters' '{' parameters+=Parameter ( "," parameters+=Parameter)* '}' )?
	    
	    ('BTA' '{' //Behavior Trace Assertions (BTA)
	    	(btaDtVar+=DataTypeVariable ("," btaDtVar+=DataTypeVariable)*)?
			(btaFormulaIds+=BtaFormulasID)*
	     '}')?
	    //Activation part 
	    ('Activation' activation = Activation )?  
	'}'
;

Activation returns Activation:
	{Activation}
	'('implCmpVar = ImplicitComponentVariable')' '{'
		(actCmpVar+=ComponentVariable (',' actCmpVar+=ComponentVariable)*)? //Declaration of Component Variables
		('DT' actDtVars=DTVariables)? //Declaration of DT Variables
		
//		//Test for the scope
//		('test' x = ActCmpVarRef )? 
//		('test1' x1 = [ActComponentVariable|ID] )? 
//		('inputtest'  y= RefActCmpVarInputPort)?
//		('outputtest' z= RefActCmpVarOutputPort)?
//		//End test for the scope
		//Formulas
		(actFormula += ActFormulasID (actFormula+= ActFormulasID)?)?
	'}'
;

ImplicitComponentVariable:
	  name=ID
;

SndImplicitComponentVariable:
	name = ID
;

Parameter returns Parameter:
	{Parameter}
	'Parameter' name=ID '(' 
		('Type' ':' paramSrtTyp=[Sort|QualifiedName])? 
	')'
;
OutputPort returns OutputPort:
	{OutputPort} 
	'OutputPort' name=ID '(' 
		('Type' ':' outputPrtSrtTyp=[Sort|QualifiedName])? 
		('connects' connects+=[InputPort|QualifiedName]*)?
		(connection = Connection)?
	')'
;
InputPort returns InputPort:
	{InputPort}	
	'InputPort' name=ID '('
		('Type' ':' inputPrtSrtTyp=[Sort|QualifiedName])?
	    ('connects' connects+=[OutputPort|QualifiedName]*)?
	')'
;
//@Long: Rule for Connection part
Connection returns Connection:
	'('implCmpVar1 = ImplicitComponentVariable ',' implCmpVar2= SndImplicitComponentVariable')' 
	'{' 
		(cntCmpVar+=ComponentVariable ("," cntCmpVar+=ComponentVariable)*)? //Declaration of Component Variables
		('DT'cntDtVars=DTVariables)? //Declaration of DT Variables
	
//		//Test for the scope
//		('test' x = ActCmpVarRef )? 
//		('inputtest'  y= RefActCmpVarInputPort)?
//		('outputtest' z= RefActCmpVarOutputPort)?
//		//End test for the scope
		//Formulas
		(actFormula += ActFormulasID (actFormula+= ActFormulasID)?)?
		
	'}'
;

DataTypeSpec returns DataTypeSpec:
	{DataTypeSpec}	
	'DT' name =ID	'('
		('Param' (dtParam+=Sort ("," dtParam+=Sort)*))?
		('Sort' (dtSorts+=Sort ("," dtSorts+=Sort)*))?
		('Operation' (dtOps+=Operation ("," dtOps+=Operation)*))?
		('Predicate' (dtPredicate+=DTPredicate ("," dtPredicate+=DTPredicate)*))?
		(sortName=[Sort|ID] 'generatedBy' (returnOps+=[Operation|ID] ("," returnOps+=[Operation|ID])*))?		
	')'
;
DTPredicate:
	name=ID ':' (pInput+=[Sort|QualifiedName] ("," pInput+=[Sort|QualifiedName])*)?
;
Operation:
	name=ID ':'  (dtInput+=[Sort|QualifiedName] ("," dtInput+=[Sort|QualifiedName])*)? '=>' (dtOutput=[Sort|QualifiedName])?
;
Sort:
	name=ID
;
//Begin common rules for CTA, Architectural Guarantee(AG) and Behavior Trace Assertions (BTA)
VariableStatus: 
	'rig' | 'flex'
;
ComponentVariable:
	status=VariableStatus	name=ID ':' cmptypAssigned=[ComponentType|ID]?
;
DataTypeVariable: 
	status=VariableStatus name=ID ':' varSortType=[Sort|QualifiedName]
;
DTVariables:
	(dtVars+=DataTypeVariable ("," dtVars+=DataTypeVariable)*)
;
PortRef:
	InputPort | OutputPort | Parameter
;
CmpVariableRef:
	cmpRef=[ComponentVariable|ID]  '.' portRef=[PortRef|ID]
;

//@Long: Implicit Component Variable References
//ImplCmpVarRef:
//	implRef = [ImplicitComponentVariable|ID] '.' implPortRef=[PortRef|ID]
//;
//RefImplCmpVarInputPort:
//	implRef = [ImplicitComponentVariable|ID] '.' implInputPortRef=[InputPort|ID]
//;
//RefImplCmpVarOutputPort:
//	implRef = [ImplicitComponentVariable|ID] '.' implOutputPortRef=[OutputPort|ID]
//;

//@Long: Common rules for both types of component variables for the activation part
ActComponentVariable:
	ImplicitComponentVariable |ComponentVariable | SndImplicitComponentVariable
;
ActCmpVarRef:
	actcmpRef = [ActComponentVariable|ID] '.' actportRef = [PortRef|ID]
;
RefActCmpVarInputPort:
	actVarRef = [ActComponentVariable|ID] '.' actInputPortRef= [InputPort|ID]
;
RefActCmpVarOutputPort:
	actVarRef = [ActComponentVariable|ID] '.' actOutputPortRef= [OutputPort|ID]
;

Term:
	cmpVariableRef=CmpVariableRef |
	dtTypeVars=[DataTypeVariable|ID] | 
	termOperatorFunction=TermOperatorFunction
;
TermOperatorFunction:
	trmOperator=[Operation|QualifiedName] "(" (trmOperands+=Term ("," trmOperands+=Term)*) ")" 
;
//RefComponentVariableParameter:
//	parameterCmpRef=[ComponentVariable|ID] '.' parameterRef=[Parameter|ID]
//;
RefComponentVariableInputPort:
	inptPrtCmpRef=[ComponentVariable|ID] '.' inputPrtrf=[InputPort|ID]
;
RefComponentVariableOutputPort:
	outptPrtCmpRef=[ComponentVariable|ID] '.' outputPrtrf=[OutputPort|ID]
;
//End

//Begin Configuration Trace Assertions(CTA) - Architectural Configuration or Configuration Trace Assertion 
//BeginBaseTerms
CtaPredicateTerms:
	ctaPTerm1=Term equalityOperator=EqualityElementOperator ctaPTerm2=Term
;
CtaPredicateConn: 
	ctaConn='conn' ('(' ctaConnCmpVarOutputPort=RefComponentVariableOutputPort ','	ctaConnCmpVarInptPort=RefComponentVariableInputPort ')')
; 
CtaPredicateEq: 
	ctaEq='eq' ('(' ctaComponentVariable1=[ComponentVariable|ID] ',' ctaComponentVariable2=[ComponentVariable|ID] ')')
;
CtaPredicateVal:
	ctaVal='val' ('(' valCmpVariableRef=CmpVariableRef ',' ctaValTerms=Term ')') 
;
CtaPredicateCAct:
	cAct='cAct' ('('cActCmpVar=[ComponentVariable|ID] ')')
;
CtaPredicatePAct:
	pAct='pAct' ('(' pActCtaCmpVaref=CmpVariableRef ')') 
;
//EndBaseTerms

//BeginCtaFormulaExpression
CtaFormula returns CtaFormula:
	ctaUnaryFormulas=CtaUnaryFormulas | 
	ctaBinaryFormulas=CtaBinaryFormulas |
	ctaQuantifiedFormulas=CtaQuantifiedFormulas
;
CtaUnaryFormulas returns CtaFormula:
	{CtaUnaryFormulas} (unaryOperator=UnaryOperator ctaFormulaLtl=CtaFormula)
;

CtaQuantifiedFormulas:
 	{CtaQuantifiedFormulas} (quantifierOperator=QuantifierOperator ctaQuantifiedFs=CtaFormula)
;
CtaBinaryFormulas returns CtaFormula:
	{CtaBinaryFormulas}	
	ctaPrimary=CtaPrimary (
		{CtaBinaryFormulas.left=current} binaryOperator=BinaryOperator right=CtaPrimary 
		)*
;
CtaPrimary returns CtaFormula:
	(ctaFormulaWithBracket=CtaFormulaWithBracket | ctaBaseTerms=CtaBaseTerms)
;
CtaFormulaWithBracket:
	leftBracket='(' ctaPrimaryFormula=CtaFormula rightBracket=')'
;
CtaBaseTerms:
		ctaPredicateTerms=CtaPredicateTerms | 
		ctaPredicateConn=CtaPredicateConn | 
		ctaPredicateVal=CtaPredicateVal | 
		ctaPredicateEq=CtaPredicateEq | //This might be duplicate to CtaPredicateTerms?
		ctaPredicateCAct=CtaPredicateCAct | 
		ctaPredicatePAct=CtaPredicatePAct 
;
//EndCtaFormulaExpression

CtaFormulasID:
	name=ID ':' ctaFormula=CtaFormula
;
// End CTA

// Begin Architectural Guarantee
//BeginBaseTerms
AgPredicateTerms:
	agPTerm1=Term equalityOperator=EqualityElementOperator agPTerm2=Term
;
AgPredicateConn: 
	agConn='conn' ('(' agConnCmpVarOutputPort=RefComponentVariableOutputPort ',' agConnCmpVarInptPort=RefComponentVariableInputPort ')')
; 
AgPredicateEq: 
	agEq='eq' ('(' agComponentVariable1=[ComponentVariable|ID] ',' agComponentVariable2=[ComponentVariable|ID] ')')
;
AgPredicateVal:
	agVal='val' ('(' valCmpVariableRef=CmpVariableRef ',' agValTerms=Term ')') 
;
AgPredicateCAct:
	cAct='cAct' ('('cActCmpVar=[ComponentVariable|ID] ')')
;
AgPredicatePAct:
	pAct='pAct' ('(' pActAgCmpVaref=CmpVariableRef ')') 
;
//EndBaseTerms

//BeginAgFormulaExpression
AgFormula returns AgFormula:
	agUnaryFormulas=AgUnaryFormulas | 
	agBinaryFormulas=AgBinaryFormulas |
	agQuantifiedFormulas=AgQuantifiedFormulas
;
AgUnaryFormulas returns AgFormula:
	{AgUnaryFormulas} (unaryOperator=UnaryOperator agFormulaLtl=AgFormula)
;
AgQuantifiedFormulas:
 	{AgQuantifiedFormulas} (quantifierOperator=QuantifierOperator agQuantifiedFs=AgFormula)
;
AgBinaryFormulas returns AgFormula:
	{AgBinaryFormulas}	
	agPrimary=AgPrimary (
		{AgBinaryFormulas.left=current} binaryOperator=BinaryOperator right=AgPrimary 
		)*
;
AgPrimary returns AgFormula:
	(agFormulaWithBracket=AgFormulaWithBracket | agBaseTerms=AgBaseTerms)
;
AgFormulaWithBracket:
	leftBracket='(' agPrimaryFormula=AgFormula rightBracket=')'
;
AgBaseTerms:
		agPredicateTerms=AgPredicateTerms | 
		agPredicateConn=AgPredicateConn | 
		agPredicateVal=AgPredicateVal | 
		agPredicateEq=AgPredicateEq |
		agPredicateCAct=AgPredicateCAct | 
		agPredicatePAct=AgPredicatePAct 
;
//EndAgFormulaExpression
AgFormulasID:
	name=ID ':' agFormula=AgFormula
;
// End AG

// Begin Behavior Trace Assertions(BTA) 
BtaTerms:
	prtRef=PortRef | DataTypeVariable	
;
BtaTermOperatorFunction:
	btaTrmOperator=[Operation|QualifiedName] "(" (btaTrmOperands+=BtaTerm ("," btaTrmOperands+=BtaTerm)*) ")"
;
BtaTerm:
	btaTerms=[BtaTerms|ID] | btaTrmOperatorFunction=BtaTermOperatorFunction
;
BtaPredicate:
	(btaTerm1=BtaTerm EqualityElementOperator btaTerm2=BtaTerm) 
;
BtUrinaryFormulas:
	UnaryOperator  btaFormulaLtl=BtaFormula
;
BtaQuantifiedFormulas:
	QuantifierOperator btaQuantifiedFs=BtaFormula 
;
BtaFormula:
	BtaPredicate | 
	BtUrinaryFormulas | 
	//BtaBinaryFormulas |  
	BtaQuantifiedFormulas
;
BtaFormulasID:
	name=ID ':' btaFormula=BtaFormula
;
//End BTA

//Begin Formula for activation part 
//BeginBaseTerms
ActTerm:
	actVariableRef= ActCmpVarRef|
	dtTypeVars=[DataTypeVariable|ID] | 
	termOperatorFunction=ActTermOperatorFunction
;
ActTermOperatorFunction:
	trmOperator=[Operation|QualifiedName] "(" (trmOperands+=ActTerm ("," trmOperands+=ActTerm)*) ")" 
;
ActPredicateTerms:
	actPTerm1=ActTerm equalityOperator=EqualityElementOperator actPTerm2=ActTerm
;
ActPredicateConn: 
	actConn='conn' ('(' actConnCmpVarOutputPort= RefActCmpVarOutputPort ','	actConnCmpVarInptPort= RefActCmpVarInputPort')'
	)
; 
ActPredicateEq: 
	actEq='eq' ('(' actComponentVariable1=[ActComponentVariable|ID] ',' 
		actComponentVariable2=[ActComponentVariable|ID] ')')
;
ActPredicateVal:
	actVal='val' ('(' valCmpVariableRef=ActCmpVarRef ',' actValTerms=ActTerm ')') 
;
ActPredicateCAct:
	cAct='cAct' ('('cActCmpVar=[ActComponentVariable|ID] ')')
;
ActPredicatePAct:
	pAct='pAct' ('(' pActCtaCmpVaref=ActCmpVarRef ')') 
;
//EndBaseTerms

NegUnaryOperator://UnaryOperator for ActFormulas, not containing G,X,F operators
	neg='¬'
;
ActBinaryOperator: //remove "W" and "U" operator from the BinaryOperator
	lAnd='∧' | 
	lDisjunct='∨' |
	lImplies='⇒' | lDoubleImplies='⇔' 
;
ActQuantifierOperator: //include also the implicit component variable
	exists='∃'actQuantifiedExistsVar=[ActComponentVariable|ID]'.' | all='∀' actQuantifiedAllVar=[ActComponentVariable|ID]'.'
;

//Begin ActFormulaExpression
ActFormula returns ActFormula:
	actUnaryFormulas=ActUnaryFormulas | 
	actBinaryFormulas=ActBinaryFormulas |
	actQuantifiedFormulas=ActQuantifiedFormulas
;
ActUnaryFormulas returns ActFormula:
	{ActUnaryFormulas} (actUnaryOperator=NegUnaryOperator actFormulaLtl=ActFormula)
;

ActQuantifiedFormulas:
 	{ActQuantifiedFormulas} (actQuantifierOperator=ActQuantifierOperator actQuantifiedFs=ActFormula)
;
ActBinaryFormulas returns ActFormula:
	{ActBinaryFormulas}	
	actPrimary=ActPrimary (
		{ActBinaryFormulas.left=current} actBinaryOperator=ActBinaryOperator right=ActPrimary 
		)*
;
ActPrimary returns ActFormula:
	(ActFormulaWithBracket=ActFormulaWithBracket | actBaseTerms=ActBaseTerms)
;
ActFormulaWithBracket:
	leftBracket='(' actPrimaryFormula=ActFormula rightBracket=')'
;
ActBaseTerms:
		actPredicateTerms=ActPredicateTerms | 
		actPredicateConn=ActPredicateConn | 
		actPredicateVal=ActPredicateVal | 
		actPredicateEq=ActPredicateEq | 
		actPredicateCAct=ActPredicateCAct | 
		actPredicatePAct=ActPredicatePAct 
;
//EndActFormulaExpression

ActFormulasID:
	name=ID ':' actFormula=ActFormula
;
// End Formula for activation part

//Begin Operator rules for CTA, BTA, and AG ....
UnaryOperator: 
	ltlG='G' | ltlX='X' |	ltlF='F' | //Linear Temporal Logic Operators
	neg='¬' // Negation logic operator
;
BinaryOperator: //operates F and F, F is a formula (CtaFormula,  AgFormula, and BtaFormula)

	lAnd='∧' | 
	lDisjunct='∨' |
	lImplies='⇒' | lDoubleImplies='⇔' |
	lWeakUntil='W' | lUntil='U' 

;
/*
BinaryOperatorOr: //operates F and F, F is a formula (CtaFormula,  AgFormula, and BtaFormula)
	lDisjunct='∨'
;
BinaryOperatorAnd:
	lAnd='∧'
;
BinaryOperatorImplies:
	lImplies='⇒' | lDoubleImplies='⇔'
;
BinaryOperatorUntil:
	lWeakUntil='W' | lUntil='U'
;
*/
EqualityElementOperator:
	'='
;

QuantifierOperator:
	exists='∃'quantifiedExistsVar=[ComponentVariable|ID]'.' | all='∀'quantifiedAllVar=[ComponentVariable|ID]'.'
;
//End
QualifiedName:
    ID ('.' ID)*
;
EString returns ecore::EString:
	STRING | ID
;