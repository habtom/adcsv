/*
 * generated by Xtext 2.14.0
 */
package org.tum.factum.pattern.validation

import org.eclipse.xtext.validation.Check
import org.tum.factum.pattern.pattern.TermOperatorFunction
import org.tum.factum.pattern.pattern.PatternPackage
import org.tum.factum.pattern.pattern.DtaOperation
import org.tum.factum.pattern.pattern.DtaPredicate
import org.tum.factum.pattern.pattern.BtaOperation
import org.tum.factum.pattern.pattern.BtaPredicate
import org.tum.factum.pattern.pattern.DtaVariable
import org.tum.factum.pattern.pattern.Sort
import org.eclipse.emf.common.util.EList
import org.tum.factum.pattern.pattern.DtaOpParam
import org.tum.factum.pattern.pattern.BtaOpParam
import org.tum.factum.pattern.pattern.BtaVariable

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class PatternValidator extends AbstractPatternValidator {
	//Validate Size of Term Inputs
	@Check
	def checkTermOperandsSize(TermOperatorFunction term) {
		if ( term.trmOperands.size != term.trmOperator.dtInput.size) {
			error("Invalid number of term operands: expected " + term.trmOperator.dtInput.size + ", not " + term.trmOperands.size + "!", 
					PatternPackage.Literals.TERM_OPERATOR_FUNCTION__TRM_OPERANDS)
		}
	}
	
	/*
	 * Validators for Datatype Assertions 
	 */
	def checkSorts(EList<Sort> signature, DtaOpParam parameters) {
		var i=0
		while (i<signature.size) {
			val param = parameters.dtaOperands.get(i)
			var pSort = null as Sort
			if (param instanceof DtaVariable) {
				val x=param as DtaVariable
				pSort=x.^var.varSortType
			} else if (param instanceof DtaOperation) {
				val x=param as DtaOperation
				pSort=x.dtaTrmOperator.dtOutput
			}
			val sSort = signature.get(i)			
			if (sSort!=pSort) {
				error("Invalid sort: expected " + sSort.name + ", not " + pSort.name, parameters, PatternPackage.Literals.DTA_OP_PARAM__DTA_OPERANDS,i)
			}				
			i++
		}
	}
	
	def calcSize(DtaOpParam parameters) {
		if (parameters === null) {
			return 0
		} else {
			return parameters.dtaOperands.size
		}
	}

	@Check
	def checkDtaOperationParamters(DtaOperation operation) {
		val signature=operation.dtaTrmOperator.dtInput
		val parameters=operation.params
		if (calcSize(parameters) != signature.size) {
			error("Invalid number of operands: expected " + signature.size + ", not " + calcSize(parameters), PatternPackage.Literals.DTA_OPERATION__DTA_TRM_OPERATOR)
		} else {
			checkSorts(signature,parameters)
		}
	}
	
	@Check
	def checkDtaPredicateParamters(DtaPredicate predicate) {
		val signature=predicate.dtaPredicate.PInput
		val parameters=predicate.params
		if (calcSize(parameters) != signature.size) {
			error("Invalid number of operands: expected " + signature.size + ", not " + calcSize(parameters), PatternPackage.Literals.DTA_PREDICATE__DTA_PREDICATE)
		} else {
			checkSorts(signature,parameters)
		}
	}

	/*
	 * Validators for Behavior Trace Assertions 
	 */
	def checkSorts(EList<Sort> signature, BtaOpParam parameters) {
		var i=0
		while (i<signature.size) {
			val param = parameters.btaOperands.get(i)
			var pSort = null as Sort
			if (param instanceof BtaVariable) {
				val x=param as BtaVariable
				pSort=x.^var.varSortType
			} else if (param instanceof BtaOperation) {
				val x=param as BtaOperation
				pSort=x.btaTrmOperator.dtOutput
			}
			val sSort = signature.get(i)			
			if (sSort!=pSort) {
				error("Invalid sort: expected " + sSort.name + ", not " + pSort.name, parameters, PatternPackage.Literals.BTA_OP_PARAM__BTA_OPERANDS,i)
			}				
			i++
		}
	}
	
	def calcSize(BtaOpParam parameters) {
		if (parameters === null) {
			return 0
		} else {
			return parameters.btaOperands.size
		}
	}

	@Check
	def checkBtaOperationParamters(BtaOperation operation) {
		val signature=operation.btaTrmOperator.dtInput
		val parameters=operation.params
		if (calcSize(parameters) != signature.size) {
			error("Invalid number of operands: expected " + signature.size + ", not " + calcSize(parameters), PatternPackage.Literals.BTA_OPERATION__BTA_TRM_OPERATOR)
		} else {
			checkSorts(signature,parameters)
		}
	}
	
	@Check
	def checkBtaPredicateParamters(BtaPredicate predicate) {
		val signature=predicate.btaPredicate.PInput
		val parameters=predicate.params
		if (calcSize(parameters) != signature.size) {
			error("Invalid number of operands: expected " + signature.size + ", not " + calcSize(parameters), PatternPackage.Literals.BTA_PREDICATE__BTA_PREDICATE)
		} else {
			checkSorts(signature,parameters)
		}
	}
}
