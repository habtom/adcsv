/*
 * generated by Xtext 2.14.0
 */
package org.tum.factum.pattern.validation

import org.eclipse.xtext.validation.Check
import org.tum.factum.pattern.pattern.TermOperatorFunction
import org.tum.factum.pattern.pattern.PatternPackage
import org.tum.factum.pattern.pattern.DtaOperation
import org.tum.factum.pattern.pattern.DtaPredicate
import org.tum.factum.pattern.pattern.BtaOperation
import org.tum.factum.pattern.pattern.BtaPredicate
import org.tum.factum.pattern.pattern.DtaVariable
import org.tum.factum.pattern.pattern.Sort
import org.eclipse.emf.common.util.EList
import org.tum.factum.pattern.pattern.DtaOpParam
import org.tum.factum.pattern.pattern.BtaOpParam
import org.tum.factum.pattern.pattern.ComponentType
import org.tum.factum.pattern.pattern.InputPort
import java.util.HashSet
import org.tum.factum.pattern.pattern.MapOperation
import org.tum.factum.pattern.pattern.OperationFunc
import org.tum.factum.pattern.pattern.BtaBaseTerm
import org.tum.factum.pattern.pattern.DataTypeVariable
import org.tum.factum.pattern.pattern.OutputPort
import org.tum.factum.pattern.pattern.Parameter
import org.tum.factum.pattern.pattern.FsmPrimitive

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class PatternValidator extends AbstractPatternValidator {
	//Validate Size of Term Inputs
	@Check
	def checkTermOperandsSize(TermOperatorFunction term) {
		if ( term.trmOperands.size != term.trmOperator.dtInput.size) {
			error("Invalid number of term operands: expected " + term.trmOperator.dtInput.size + ", not " + term.trmOperands.size + "!", 
					PatternPackage.Literals.TERM_OPERATOR_FUNCTION__TRM_OPERANDS)
		}
	}
	
	/*
	 * Validators for Datatype Assertions 
	 */
	def checkSorts(EList<Sort> signature, DtaOpParam parameters) {
		var i=0
		while (i<signature.size) {
			val param = parameters.dtaOperands.get(i)
			var pSort = null as Sort
			if (param instanceof DtaVariable) {
				val x=param as DtaVariable
				pSort=x.^var.varSortType
			} else if (param instanceof DtaOperation) {
				val x=param as DtaOperation
				pSort=x.dtaTrmOperator.dtOutput
			}
			val sSort = signature.get(i)			
			if (sSort!=pSort) {
				error("Invalid sort: expected " + sSort.name + ", not " + pSort.name, parameters, PatternPackage.Literals.DTA_OP_PARAM__DTA_OPERANDS,i)
			}				
			i++
		}
	}
	
	def calcSize(DtaOpParam parameters) {
		if (parameters === null) {
			return 0
		} else {
			return parameters.dtaOperands.size
		}
	}

	@Check
	def checkDtaOperationParamters(DtaOperation operation) {
		val signature=operation.dtaTrmOperator.dtInput
		val parameters=operation.params
		if (calcSize(parameters) != signature.size) {
			error("Invalid number of operands: expected " + signature.size + ", not " + calcSize(parameters), PatternPackage.Literals.DTA_OPERATION__DTA_TRM_OPERATOR)
		} else {
			checkSorts(signature,parameters)
		}
	}
	
	@Check
	def checkDtaPredicateParamters(DtaPredicate predicate) {
		val signature=predicate.dtaPredicate.PInput
		val parameters=predicate.params
		if (calcSize(parameters) != signature.size) {
			error("Invalid number of operands: expected " + signature.size + ", not " + calcSize(parameters), PatternPackage.Literals.DTA_PREDICATE__DTA_PREDICATE)
		} else {
			checkSorts(signature,parameters)
		}
	}

	/*
	 * Validators for Component Types 
	 */
	@Check
	def checkCTPorts(ComponentType cType) {
		var i=0
		while (i<cType.outputPorts.size) {
			val oPort=cType.outputPorts.get(i)
			if (cType.inputPorts.exists[name.equals(oPort.name)]) {
				error("An input port with the same name already exists!",PatternPackage.Literals.COMPONENT_TYPE__OUTPUT_PORTS,i)
			}
			i++
		}
		i=0
		while (i<cType.parameters.size) {
			val par=cType.outputPorts.get(i)
			if (cType.inputPorts.exists[name.equals(par.name)]) {
				error("An input port with the same name already exists!",PatternPackage.Literals.COMPONENT_TYPE__PARAMETERS,i)
			} else if (cType.outputPorts.exists[name.equals(par.name)]) {
				error("An output port with the same name already exists!",PatternPackage.Literals.COMPONENT_TYPE__PARAMETERS,i)
			}
		}
	}

	/*
	 * Validators for Behavior Trace Assertions 
	 */
	def checkSorts(EList<Sort> signature, BtaOpParam parameters) {
		var i=0
		while (i<signature.size) {
			val param = parameters.btaOperands.get(i)
			var pSort = null as Sort
			if (param instanceof BtaBaseTerm) {
				val x=param as BtaBaseTerm
				val pRef=x.^btaRef
				if (pRef instanceof DataTypeVariable) {
					val dtaVar = pRef as DataTypeVariable
					pSort=dtaVar.varSortType
				} else if (pRef instanceof InputPort) {
					val iPort = pRef as InputPort
					pSort=iPort.inputPrtSrtTyp
				} else if (pRef instanceof OutputPort) {
					val iPort = pRef as OutputPort
					pSort=iPort.outputPrtSrtTyp
				} else if (pRef instanceof Parameter) {
					val iPort = pRef as Parameter
					pSort=iPort.paramSrtTyp
				}
			} else if (param instanceof BtaOperation) {
				val x=param as BtaOperation
				pSort=x.btaTrmOperator.dtOutput
			}
			val sSort = signature.get(i)			
			if (sSort!=pSort) {
				error("Invalid sort: expected " + sSort.name + ", not " + pSort.name, parameters, PatternPackage.Literals.BTA_OP_PARAM__BTA_OPERANDS,i)
			}				
			i++
		}
	}
	
	def calcSize(BtaOpParam parameters) {
		if (parameters === null) {
			return 0
		} else {
			return parameters.btaOperands.size
		}
	}

	@Check
	def checkBtaOperationParamters(BtaOperation operation) {
		val signature=operation.btaTrmOperator.dtInput
		val parameters=operation.params
		if (calcSize(parameters) != signature.size) {
			error("Invalid number of operands: expected " + signature.size + ", not " + calcSize(parameters), PatternPackage.Literals.BTA_OPERATION__BTA_TRM_OPERATOR)
		} else {
			checkSorts(signature,parameters)
		}
	}
	
	@Check
	def checkBtaPredicateParamters(BtaPredicate predicate) {
		val signature=predicate.btaPredicate.PInput
		val parameters=predicate.params
		if (calcSize(parameters) != signature.size) {
			error("Invalid number of operands: expected " + signature.size + ", not " + calcSize(parameters), PatternPackage.Literals.BTA_PREDICATE__BTA_PREDICATE)
		} else {
			checkSorts(signature,parameters)
		}
	}
	
	// FSM
	@Check
	def checkInitialParameter(ComponentType ct) {
		val btaVars = ct.btaDtVar
		val init = ct.initial
		val initVars = init.vars
		if (hasDuplicate(initVars)) {
			error("Invalid redeclaration of variable", init, PatternPackage.Literals.INITIALISATION__VARS)
		}
		if (btaVars.size > init.vars.size) {
			warning("Not all variables have been initialized", init, PatternPackage.Literals.INITIALISATION__VARS)
		} 
		var i = 0
		for (variable : initVars) {
			var dataTypes = init.dataTypes
			if (dataTypes.size > i) {
				var a = dataTypes.get(i)
				var btaVar = a.variable
				if (btaVar == variable) {
					error("Invalid self declaration ", init, PatternPackage.Literals.INITIALISATION__VARS, i)
				}
			}
			i++
		}	
	}
	
	@Check
	def checkMapOperationSize(MapOperation mo) {
		val signature = mo.op.dtInput
		val parameters = mo.vars
		if (parameters.size != signature.size) {
			error("Invalid number of operands: expected " + signature.size + ", not " + parameters.size, PatternPackage.Literals.MAP_OPERATION__VARS)
		} 
	}
	
	@Check
	def checkFsmOperation(OperationFunc of) {
		val signature = of.op.dtInput
		val parameters = of.params
		if (parameters.size != signature.size) {
			error("Invalid number of operands: expected " + signature.size + ", not " + parameters.size, PatternPackage.Literals.OPERATION_FUNC__PARAMS)
		} else {
			checkSortsOp(signature, parameters)
		} 
		
	}
	
	def checkSortsOp(EList<Sort> signature, EList<FsmPrimitive> parameters) {
		val iteratorSign = signature.iterator
		val iteratorParam = parameters.iterator
		var i = 0
		while (iteratorSign.hasNext && iteratorParam.hasNext) {
			var param = iteratorParam.next
			var sort = iteratorSign.next
			if (param.dtVar !== null && param.dtVar.varSortType != sort) {
				error("Invalid sort: expected " + sort.name + ", not " + param.dtVar.varSortType.name, PatternPackage.Literals.OPERATION_FUNC__PARAMS)
			}
			i++
		}
	}
	
	def <T> boolean hasDuplicate(Iterable<T> all) {
    	val set = new HashSet<T>();
    	for (T each: all) if (!set.add(each)) return true;
    	return false;
	}

}
