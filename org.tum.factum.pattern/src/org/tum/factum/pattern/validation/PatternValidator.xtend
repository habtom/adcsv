/*
 * generated by Xtext 2.14.0
 */
package org.tum.factum.pattern.validation

import org.eclipse.xtext.validation.Check
import org.tum.factum.pattern.pattern.TermOperatorFunction
import org.tum.factum.pattern.pattern.PatternPackage
import org.tum.factum.pattern.pattern.DtaOperation
import org.tum.factum.pattern.pattern.DtaPredicate
import org.tum.factum.pattern.pattern.BtaOperation
import org.tum.factum.pattern.pattern.BtaPredicate
import org.tum.factum.pattern.pattern.DtaVariable
import org.tum.factum.pattern.pattern.Sort
import org.eclipse.emf.common.util.EList
import org.tum.factum.pattern.pattern.DtaOpParam
import org.tum.factum.pattern.pattern.BtaOpParam
import org.tum.factum.pattern.pattern.BtaVariable
import org.tum.factum.pattern.pattern.FsmPrimitive
import org.tum.factum.pattern.pattern.ComponentType
import org.tum.factum.pattern.pattern.InputPort
import java.util.HashSet

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class PatternValidator extends AbstractPatternValidator {
	//Validate Size of Term Inputs
	@Check
	def checkTermOperandsSize(TermOperatorFunction term) {
		if ( term.trmOperands.size != term.trmOperator.dtInput.size) {
			error("Invalid number of term operands: expected " + term.trmOperator.dtInput.size + ", not " + term.trmOperands.size + "!", 
					PatternPackage.Literals.TERM_OPERATOR_FUNCTION__TRM_OPERANDS)
		}
	}
	
	/*
	 * Validators for Datatype Assertions 
	 */
	def checkSorts(EList<Sort> signature, DtaOpParam parameters) {
		var i=0
		while (i<signature.size) {
			val param = parameters.dtaOperands.get(i)
			var pSort = null as Sort
			if (param instanceof DtaVariable) {
				val x=param as DtaVariable
				pSort=x.^var.varSortType
			} else if (param instanceof DtaOperation) {
				val x=param as DtaOperation
				pSort=x.dtaTrmOperator.dtOutput
			}
			val sSort = signature.get(i)			
			if (sSort!=pSort) {
				error("Invalid sort: expected " + sSort.name + ", not " + pSort.name, parameters, PatternPackage.Literals.DTA_OP_PARAM__DTA_OPERANDS,i)
			}				
			i++
		}
	}
	
	def calcSize(DtaOpParam parameters) {
		if (parameters === null) {
			return 0
		} else {
			return parameters.dtaOperands.size
		}
	}

	@Check
	def checkDtaOperationParamters(DtaOperation operation) {
		val signature=operation.dtaTrmOperator.dtInput
		val parameters=operation.params
		if (calcSize(parameters) != signature.size) {
			error("Invalid number of operands: expected " + signature.size + ", not " + calcSize(parameters), PatternPackage.Literals.DTA_OPERATION__DTA_TRM_OPERATOR)
		} else {
			checkSorts(signature,parameters)
		}
	}
	
	@Check
	def checkDtaPredicateParamters(DtaPredicate predicate) {
		val signature=predicate.dtaPredicate.PInput
		val parameters=predicate.params
		if (calcSize(parameters) != signature.size) {
			error("Invalid number of operands: expected " + signature.size + ", not " + calcSize(parameters), PatternPackage.Literals.DTA_PREDICATE__DTA_PREDICATE)
		} else {
			checkSorts(signature,parameters)
		}
	}

	/*
	 * Validators for Behavior Trace Assertions 
	 */
	def checkSorts(EList<Sort> signature, BtaOpParam parameters) {
		var i=0
		while (i<signature.size) {
			val param = parameters.btaOperands.get(i)
			var pSort = null as Sort
			if (param instanceof BtaVariable) {
				val x=param as BtaVariable
				pSort=x.^var.varSortType
			} else if (param instanceof BtaOperation) {
				val x=param as BtaOperation
				pSort=x.btaTrmOperator.dtOutput
			}
			val sSort = signature.get(i)			
			if (sSort!=pSort) {
				error("Invalid sort: expected " + sSort.name + ", not " + pSort.name, parameters, PatternPackage.Literals.BTA_OP_PARAM__BTA_OPERANDS,i)
			}				
			i++
		}
	}
	
	def calcSize(BtaOpParam parameters) {
		if (parameters === null) {
			return 0
		} else {
			return parameters.btaOperands.size
		}
	}

	@Check
	def checkBtaOperationParamters(BtaOperation operation) {
		val signature=operation.btaTrmOperator.dtInput
		val parameters=operation.params
		if (calcSize(parameters) != signature.size) {
			error("Invalid number of operands: expected " + signature.size + ", not " + calcSize(parameters), PatternPackage.Literals.BTA_OPERATION__BTA_TRM_OPERATOR)
		} else {
			checkSorts(signature,parameters)
		}
	}
	
	@Check
	def checkBtaPredicateParamters(BtaPredicate predicate) {
		val signature=predicate.btaPredicate.PInput
		val parameters=predicate.params
		if (calcSize(parameters) != signature.size) {
			error("Invalid number of operands: expected " + signature.size + ", not " + calcSize(parameters), PatternPackage.Literals.BTA_PREDICATE__BTA_PREDICATE)
		} else {
			checkSorts(signature,parameters)
		}
	}
	
	// FSM
//	@Check
//	def checkInitialParameter(ComponentType ct) {
//		val btaVars = ct.getBtaDtVar()
//		val init = ct.getInitial()
//		val initVars = init.getVars()
//		if (hasDuplicate(initVars)) {
//			error("Invalid redeclaration of variable", init, PatternPackage.Literals.INITIALISATION__VARS)
//		}
//		if (btaVars.size() > init.vars.size()) {
//			warning("Not all variables have been initialized", init, PatternPackage.Literals.INITIALISATION__INITIAL)
//		} 
//		var i = 0
//		for (variable : initVars) {
//			var dataTypes = init.getDataTypes()
//			if (dataTypes.size() > i) {
//				var a = dataTypes.get(i)
//				var btaVar = a.getVariable()
//				if (btaVar == variable) {
//					error("Invalid self declaration ", init, PatternPackage.Literals.INITIALISATION__VARS)
//				}
//			}
//			i++
//		}	
//	}
	
	def <T> boolean hasDuplicate(Iterable<T> all) {
    	val set = new HashSet<T>();
    	for (T each: all) if (!set.add(each)) return true;
    	return false;
	}

}
